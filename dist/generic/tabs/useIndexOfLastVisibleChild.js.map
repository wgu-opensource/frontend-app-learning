{"version":3,"sources":["../../../src/generic/tabs/useIndexOfLastVisibleChild.js"],"names":["invisibleStyle","position","left","pointerEvents","visibility","useIndexOfLastVisibleChild","containerElementRef","overflowElementRef","containingRectRef","indexOfLastVisibleChild","setIndexOfLastVisibleChild","windowSize","containingRect","current","getBoundingClientRect","width","childNodesArr","Array","prototype","slice","call","children","nextIndexOfLastVisibleChild","filter","childNode","reduce","acc","index","sumWidth","Math","floor"],"mappings":";;;;;;;AAAA;;AACA;;AAEA,MAAMA,cAAc,GAAG;AACrBC,EAAAA,QAAQ,EAAE,UADW;AAErBC,EAAAA,IAAI,EAAE,CAFe;AAGrBC,EAAAA,aAAa,EAAE,MAHM;AAIrBC,EAAAA,UAAU,EAAE;AAJS,CAAvB;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACe,SAASC,0BAAT,GAAsC;AACnD,QAAMC,mBAAmB,GAAG,mBAAO,IAAP,CAA5B;AACA,QAAMC,kBAAkB,GAAG,mBAAO,IAAP,CAA3B;AACA,QAAMC,iBAAiB,GAAG,mBAAO,EAAP,CAA1B;AACA,QAAM,CAACC,uBAAD,EAA0BC,0BAA1B,IAAwD,qBAAS,CAAC,CAAV,CAA9D;AACA,QAAMC,UAAU,GAAG,6BAAnB;AAEA,8BAAgB,MAAM;AACpB,UAAMC,cAAc,GAAGN,mBAAmB,CAACO,OAApB,CAA4BC,qBAA5B,EAAvB,CADoB,CAGpB;AACA;;AACA,QAAI,CAACF,cAAc,CAACG,KAAhB,KAA0BP,iBAAiB,CAACK,OAAlB,CAA0BE,KAAxD,EAA+D;AAC7D;AACD,KAPmB,CAQpB;;;AACAP,IAAAA,iBAAiB,CAACK,OAAlB,GAA4BD,cAA5B,CAToB,CAWpB;;AACA,UAAMI,aAAa,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2Bd,mBAAmB,CAACO,OAApB,CAA4BQ,QAAvD,CAAtB;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAkCN,aAAa,CACnD;AADmD,KAElDO,MAFqC,CAE9BC,SAAS,IAAIA,SAAS,KAAKjB,kBAAkB,CAACM,OAFhB,EAGtC;AAHsC,KAIrCY,MAJqC,CAI9B,CAACC,GAAD,EAAMF,SAAN,EAAiBG,KAAjB,KAA2B;AACjC;AACAD,MAAAA,GAAG,CAACE,QAAJ,IAAgBC,IAAI,CAACC,KAAL,CAAWN,SAAS,CAACV,qBAAV,GAAkCC,KAA7C,CAAhB;;AACA,UAAIW,GAAG,CAACE,QAAJ,IAAgBhB,cAAc,CAACG,KAAnC,EAA0C;AACxCW,QAAAA,GAAG,CAACJ,2BAAJ,GAAkCK,KAAlC;AACD;;AACD,aAAOD,GAAP;AACD,KAXqC,EAWnC;AACD;AACA;AACA;AACA;AACAE,MAAAA,QAAQ,EAAErB,kBAAkB,CAACM,OAAnB,GAA6BN,kBAAkB,CAACM,OAAnB,CAA2BC,qBAA3B,GAAmDC,KAAhF,GAAwF,CALjG;AAMDO,MAAAA,2BAA2B,EAAE,CAAC;AAN7B,KAXmC,CAAxC;AAoBAZ,IAAAA,0BAA0B,CAACY,2BAAD,CAA1B;AACD,GAlCD,EAkCG,CAACX,UAAD,EAAaL,mBAAmB,CAACO,OAAjC,CAlCH;AAoCA,SAAO,CAACJ,uBAAD,EAA0BH,mBAA1B,EAA+CN,cAA/C,EAA+DO,kBAA/D,CAAP;AACD","sourcesContent":["import { useLayoutEffect, useRef, useState } from 'react';\nimport { useWindowSize } from '@edx/paragon';\n\nconst invisibleStyle = {\n  position: 'absolute',\n  left: 0,\n  pointerEvents: 'none',\n  visibility: 'hidden',\n};\n\n/**\n * This hook will find the index of the last child of a containing element\n * that fits within its bounding rectangle. This is done by summing the widths\n * of the children until they exceed the width of the container.\n *\n * The hook returns an array containing:\n * [indexOfLastVisibleChild, containerElementRef, invisibleStyle, overflowElementRef]\n *\n * indexOfLastVisibleChild - the index of the last visible child\n * containerElementRef - a ref to be added to the containing html node\n * invisibleStyle - a set of styles to be applied to child of the containing node\n *    if it needs to be hidden. These styles remove the element visually, from\n *    screen readers, and from normal layout flow. But, importantly, these styles\n *    preserve the width of the element, so that future width calculations will\n *    still be accurate.\n * overflowElementRef - a ref to be added to an html node inside the container\n *    that is likely to be used to contain a \"More\" type dropdown or other\n *    mechanism to reveal hidden children. The width of this element is always\n *    included when determining which children will fit or not. Usage of this ref\n *    is optional.\n */\nexport default function useIndexOfLastVisibleChild() {\n  const containerElementRef = useRef(null);\n  const overflowElementRef = useRef(null);\n  const containingRectRef = useRef({});\n  const [indexOfLastVisibleChild, setIndexOfLastVisibleChild] = useState(-1);\n  const windowSize = useWindowSize();\n\n  useLayoutEffect(() => {\n    const containingRect = containerElementRef.current.getBoundingClientRect();\n\n    // No-op if the width is unchanged.\n    // (Assumes tabs themselves don't change count or width).\n    if (!containingRect.width === containingRectRef.current.width) {\n      return;\n    }\n    // Update for future comparison\n    containingRectRef.current = containingRect;\n\n    // Get array of child nodes from NodeList form\n    const childNodesArr = Array.prototype.slice.call(containerElementRef.current.children);\n    const { nextIndexOfLastVisibleChild } = childNodesArr\n      // filter out the overflow element\n      .filter(childNode => childNode !== overflowElementRef.current)\n      // sum the widths to find the last visible element's index\n      .reduce((acc, childNode, index) => {\n        // use floor to prevent rounding errors\n        acc.sumWidth += Math.floor(childNode.getBoundingClientRect().width);\n        if (acc.sumWidth <= containingRect.width) {\n          acc.nextIndexOfLastVisibleChild = index;\n        }\n        return acc;\n      }, {\n        // Include the overflow element's width to begin with. Doing this means\n        // sometimes we'll show a dropdown with one item in it when it would fit,\n        // but allowing this case dramatically simplifies the calculations we need\n        // to do above.\n        sumWidth: overflowElementRef.current ? overflowElementRef.current.getBoundingClientRect().width : 0,\n        nextIndexOfLastVisibleChild: -1,\n      });\n\n    setIndexOfLastVisibleChild(nextIndexOfLastVisibleChild);\n  }, [windowSize, containerElementRef.current]);\n\n  return [indexOfLastVisibleChild, containerElementRef, invisibleStyle, overflowElementRef];\n}\n"],"file":"useIndexOfLastVisibleChild.js"}