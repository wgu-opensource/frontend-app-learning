{"version":3,"file":"useIndexOfLastVisibleChild.js","names":["_react","require","_paragon","invisibleStyle","position","left","pointerEvents","visibility","maxWidth","useIndexOfLastVisibleChild","containerElementRef","useRef","overflowElementRef","containingRectRef","indexOfLastVisibleChild","setIndexOfLastVisibleChild","useState","windowSize","useWindowSize","useLayoutEffect","containingRect","current","getBoundingClientRect","width","childNodesArr","Array","prototype","slice","call","children","nextIndexOfLastVisibleChild","filter","childNode","reduce","acc","index","sumWidth","Math","floor"],"sources":["../../../src/generic/tabs/useIndexOfLastVisibleChild.js"],"sourcesContent":["import { useLayoutEffect, useRef, useState } from 'react';\nimport { useWindowSize } from '@edx/paragon';\n\nconst invisibleStyle = {\n  position: 'absolute',\n  left: 0,\n  pointerEvents: 'none',\n  visibility: 'hidden',\n  maxWidth: '100%',\n};\n\n/**\n * This hook will find the index of the last child of a containing element\n * that fits within its bounding rectangle. This is done by summing the widths\n * of the children until they exceed the width of the container.\n *\n * The hook returns an array containing:\n * [indexOfLastVisibleChild, containerElementRef, invisibleStyle, overflowElementRef]\n *\n * indexOfLastVisibleChild - the index of the last visible child\n * containerElementRef - a ref to be added to the containing html node\n * invisibleStyle - a set of styles to be applied to child of the containing node\n *    if it needs to be hidden. These styles remove the element visually, from\n *    screen readers, and from normal layout flow. But, importantly, these styles\n *    preserve the width of the element, so that future width calculations will\n *    still be accurate.\n * overflowElementRef - a ref to be added to an html node inside the container\n *    that is likely to be used to contain a \"More\" type dropdown or other\n *    mechanism to reveal hidden children. The width of this element is always\n *    included when determining which children will fit or not. Usage of this ref\n *    is optional.\n */\nexport default function useIndexOfLastVisibleChild() {\n  const containerElementRef = useRef(null);\n  const overflowElementRef = useRef(null);\n  const containingRectRef = useRef({});\n  const [indexOfLastVisibleChild, setIndexOfLastVisibleChild] = useState(-1);\n  const windowSize = useWindowSize();\n\n  useLayoutEffect(() => {\n    const containingRect = containerElementRef.current.getBoundingClientRect();\n\n    // No-op if the width is unchanged.\n    // (Assumes tabs themselves don't change count or width).\n    if (!containingRect.width === containingRectRef.current.width) {\n      return;\n    }\n    // Update for future comparison\n    containingRectRef.current = containingRect;\n\n    // Get array of child nodes from NodeList form\n    const childNodesArr = Array.prototype.slice.call(containerElementRef.current.children);\n    const { nextIndexOfLastVisibleChild } = childNodesArr\n      // filter out the overflow element\n      .filter(childNode => childNode !== overflowElementRef.current)\n      // sum the widths to find the last visible element's index\n      .reduce((acc, childNode, index) => {\n        // use floor to prevent rounding errors\n        acc.sumWidth += Math.floor(childNode.getBoundingClientRect().width);\n        if (acc.sumWidth <= containingRect.width) {\n          acc.nextIndexOfLastVisibleChild = index;\n        }\n        return acc;\n      }, {\n        // Include the overflow element's width to begin with. Doing this means\n        // sometimes we'll show a dropdown with one item in it when it would fit,\n        // but allowing this case dramatically simplifies the calculations we need\n        // to do above.\n        sumWidth: overflowElementRef.current ? overflowElementRef.current.getBoundingClientRect().width : 0,\n        nextIndexOfLastVisibleChild: -1,\n      });\n\n    setIndexOfLastVisibleChild(nextIndexOfLastVisibleChild);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [windowSize, containerElementRef.current]);\n\n  return [indexOfLastVisibleChild, containerElementRef, invisibleStyle, overflowElementRef];\n}\n"],"mappings":";;;;;;AAAA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AAEA,MAAME,cAAc,GAAG;EACrBC,QAAQ,EAAE,UAAU;EACpBC,IAAI,EAAE,CAAC;EACPC,aAAa,EAAE,MAAM;EACrBC,UAAU,EAAE,QAAQ;EACpBC,QAAQ,EAAE;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASC,0BAA0BA,CAAA,EAAG;EACnD,MAAMC,mBAAmB,GAAG,IAAAC,aAAM,EAAC,IAAI,CAAC;EACxC,MAAMC,kBAAkB,GAAG,IAAAD,aAAM,EAAC,IAAI,CAAC;EACvC,MAAME,iBAAiB,GAAG,IAAAF,aAAM,EAAC,CAAC,CAAC,CAAC;EACpC,MAAM,CAACG,uBAAuB,EAAEC,0BAA0B,CAAC,GAAG,IAAAC,eAAQ,EAAC,CAAC,CAAC,CAAC;EAC1E,MAAMC,UAAU,GAAG,IAAAC,sBAAa,EAAC,CAAC;EAElC,IAAAC,sBAAe,EAAC,MAAM;IACpB,MAAMC,cAAc,GAAGV,mBAAmB,CAACW,OAAO,CAACC,qBAAqB,CAAC,CAAC;;IAE1E;IACA;IACA,IAAI,CAACF,cAAc,CAACG,KAAK,KAAKV,iBAAiB,CAACQ,OAAO,CAACE,KAAK,EAAE;MAC7D;IACF;IACA;IACAV,iBAAiB,CAACQ,OAAO,GAAGD,cAAc;;IAE1C;IACA,MAAMI,aAAa,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAAClB,mBAAmB,CAACW,OAAO,CAACQ,QAAQ,CAAC;IACtF,MAAM;MAAEC;IAA4B,CAAC,GAAGN;IACtC;IAAA,CACCO,MAAM,CAACC,SAAS,IAAIA,SAAS,KAAKpB,kBAAkB,CAACS,OAAO;IAC7D;IAAA,CACCY,MAAM,CAAC,CAACC,GAAG,EAAEF,SAAS,EAAEG,KAAK,KAAK;MACjC;MACAD,GAAG,CAACE,QAAQ,IAAIC,IAAI,CAACC,KAAK,CAACN,SAAS,CAACV,qBAAqB,CAAC,CAAC,CAACC,KAAK,CAAC;MACnE,IAAIW,GAAG,CAACE,QAAQ,IAAIhB,cAAc,CAACG,KAAK,EAAE;QACxCW,GAAG,CAACJ,2BAA2B,GAAGK,KAAK;MACzC;MACA,OAAOD,GAAG;IACZ,CAAC,EAAE;MACD;MACA;MACA;MACA;MACAE,QAAQ,EAAExB,kBAAkB,CAACS,OAAO,GAAGT,kBAAkB,CAACS,OAAO,CAACC,qBAAqB,CAAC,CAAC,CAACC,KAAK,GAAG,CAAC;MACnGO,2BAA2B,EAAE,CAAC;IAChC,CAAC,CAAC;IAEJf,0BAA0B,CAACe,2BAA2B,CAAC;IACzD;EACA,CAAC,EAAE,CAACb,UAAU,EAAEP,mBAAmB,CAACW,OAAO,CAAC,CAAC;EAE7C,OAAO,CAACP,uBAAuB,EAAEJ,mBAAmB,EAAEP,cAAc,EAAES,kBAAkB,CAAC;AAC3F"}