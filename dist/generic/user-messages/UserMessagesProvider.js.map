{"version":3,"sources":["../../../src/generic/user-messages/UserMessagesProvider.jsx"],"names":["ALERT_TYPES","ERROR","DANGER","SUCCESS","INFO","WELCOME","FLASH_MESSAGES_LOCAL_STORAGE_KEY","addFlashMessage","message","flashMessages","Array","isArray","push","popFlashMessages","UserMessagesProvider","children","messages","setMessages","nextId","setNextId","refId","addFlash","add","code","dismissible","text","type","topic","payload","others","id","current","currentMessages","remove","filter","clear","forEach","flashMessage","value","propTypes","PropTypes","node","defaultProps"],"mappings":"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","sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport PropTypes from 'prop-types';\n\nimport UserMessagesContext from './UserMessagesContext';\nimport { getLocalStorage, popLocalStorage, setLocalStorage } from '../../data/localStorage';\n\nexport const ALERT_TYPES = {\n  ERROR: 'error',\n  DANGER: 'danger',\n  SUCCESS: 'success',\n  INFO: 'info',\n  WELCOME: 'welcome',\n};\n\nconst FLASH_MESSAGES_LOCAL_STORAGE_KEY = 'UserMessagesProvider.flashMessages';\n\nfunction addFlashMessage(message) {\n  let flashMessages = getLocalStorage(FLASH_MESSAGES_LOCAL_STORAGE_KEY);\n  if (!flashMessages || !Array.isArray(flashMessages)) {\n    flashMessages = [];\n  }\n  flashMessages.push(message);\n  setLocalStorage(FLASH_MESSAGES_LOCAL_STORAGE_KEY, flashMessages);\n}\n\nfunction popFlashMessages() {\n  return popLocalStorage(FLASH_MESSAGES_LOCAL_STORAGE_KEY) || [];\n}\n\nexport default function UserMessagesProvider({ children }) {\n  // Note: The callbacks (add, remove, clear) below interact with useState in very subtle ways.\n  // When we call setMessages, we always do so with the function-based form of the handler, making\n  // use of the \"current\" state and not relying on lexical scoping to access the state exposed\n  // above with useState.  This is very important and allows us to call multiple \"add\", \"remove\",\n  // or \"clear\" functions in a  single render.  Without it, each call to one of the callbacks\n  // references back to the -original- value of messages instead of the most recent, causing them\n  // all to override each other.  Last one in would win.\n  const [messages, setMessages] = useState([]);\n  const [nextId, setNextId] = useState(1);\n\n  // Because the add, remove, and clear handlers also need to access nextId, we have to do\n  // something a bit different.  There's no way to wait for the \"currentNextId\" in a setMessages\n  // handler.  The alternative is to update a ref, which will always point to the current value by\n  // its very nature.\n  const refId = useRef(nextId);\n\n  /**\n   * Flash messages are a special kind of message that appears once on page refresh.\n   */\n  function addFlash(message) {\n    addFlashMessage(message);\n  }\n\n  function add(message) {\n    const {\n      code, dismissible, text, type, topic, payload, ...others\n    } = message;\n    const id = refId.current;\n    setMessages(currentMessages => [...currentMessages, {\n      code, dismissible, text, type, topic, payload, ...others, id,\n    }]);\n    refId.current += 1;\n    setNextId(refId.current);\n\n    return id;\n  }\n\n  function remove(id) {\n    setMessages(currentMessages => currentMessages.filter(message => message.id !== id));\n  }\n\n  function clear(topic = null) {\n    setMessages(currentMessages => (topic === null ? [] : currentMessages.filter(message => message.topic !== topic)));\n  }\n\n  useEffect(() => {\n    // We only allow flash messages to persist through one refresh, then we clear them out.\n    // If we want persistent messages, then add a 'persist' key to the messages and handle that\n    // as a separate local storage item.\n    const flashMessages = popFlashMessages();\n    flashMessages.forEach(flashMessage => add(flashMessage));\n  }, []);\n\n  const value = {\n    add,\n    addFlash,\n    remove,\n    clear,\n    messages,\n  };\n\n  return (\n    <UserMessagesContext.Provider value={value}>\n      {children}\n    </UserMessagesContext.Provider>\n  );\n}\n\nUserMessagesProvider.propTypes = {\n  children: PropTypes.node,\n};\n\nUserMessagesProvider.defaultProps = {\n  children: null,\n};\n"],"file":"UserMessagesProvider.js"}